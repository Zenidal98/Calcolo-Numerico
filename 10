import numpy as np
import matplotlib.pyplot as plt

def succ_app(f, g, tolf, tolx, maxit, xTrue, x0=0):

    err_sol_succ = np.zeros(maxit+1, dtype=np.float64)
    vecErrore_true = np.zeros(maxit+1, dtype=np.float64)

    i = 0
    err_sol_succ[0]= tolx +1
    vecErrore_true[0] = np.abs(x0 - xTrue)
    x = x0

    while( not(np.abs(f(x)) < tolf and np.abs(x-x_new) < tolx) and i < maxit ):
        x_new = g(x)
        err_sol_succ[i] = abs(x_new - x)
        vecErrore_true[i] = abs(x - xTrue)
        i=i+1
        x = x_new

    err_sol_succ = err_sol_succ[0:i]
    vecErrore_true = vecErrore_true[0:i]
    return (x, i, err_sol_succ, vecErrore_true)

def newton( f, df, tolf, tolx, maxit, xTrue, x0=0):

    g = lambda x: x - (f(x) / df(x))
    (x, i, err_sol_succ, vecErrore_true) = succ_app(f, g, tolf, tolx, maxit, xTrue, x0)

    return (x, i, err_sol_succ, vecErrore_true)

                                    #-Confronto delle prestazioni dei due metodi-

tolx= 10**(-10)
tolf = 10**(-6)
maxit=100
x0= 1
xTrue = 3.5213

f1 = lambda x: x - x**(1/3) - 2
df1 = lambda x: 1 - (1/3)*x**(-2/3)
g = lambda x: x**(1/3) + 2
a1 = 3
b1 = 5
x1_plot = np.linspace(a1, b1, 101)
f1_plot = f1(x1_plot)

print('xTrue Ã¨ 3.5213')


#plot funzione
plt.plot(x1_plot, f1_plot, 'b')
plt.grid()
plt.xlabel('x')
plt.ylabel('y')
plt.title('funzione f1 = x - x**(1/3) - 2')
plt.show()

#confronto metodi
(x1_newton, i1_newton, diff1_newton, err1_newton) = newton(f1, df1, tolf, tolx, maxit, xTrue, x0)
print('Metodo di Newton \n x =', x1_newton,'\n iter_new=', i1_newton, '\n err_new=', diff1_newton)

(x1_succ, i1_succ, diff1_succ, err1_succ) = succ_app(f1, g, tolf, tolx, maxit, xTrue, x0)
print('Metodo approssimazioni successive g \n x =', x1_succ, '\n iter_succ=', i1_succ, '\n')

                                           #-Grafico errore e interazioni-

# Newton
iter1_newton = np.arange(0, i1_newton)
plt.plot(iter1_newton, diff1_newton, 'g')
plt.grid()
plt.xlabel('iter_newton')
plt.ylabel('err_newon')
plt.title('Newton')
plt.show()
# approssimazioni successive g
iter1_succ = np.arange(0, i1_succ)
plt.plot(iter1_succ, diff1_succ, 'r')
plt.grid()
plt.xlabel('iter_succ1')
plt.ylabel('err_succ1')
plt.title('approssimazioni successive g = x**(1/3) + 2')
plt.show()
